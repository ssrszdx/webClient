{"version":3,"file":"440.prod.js","mappings":"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","sources":["webpack://tinode-webapp/./src/widgets/audio-recorder.jsx"],"sourcesContent":["// Audio recorder widget.\r\n\r\nimport React from 'react';\r\nimport { defineMessages, injectIntl } from 'react-intl';\r\n\r\nimport AudioPlayer from './audio-player.jsx';\r\n// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=642012\r\n// It adds duration and SeekHead to the webm record.\r\nimport fixWebmDuration from 'webm-duration-fix';\r\n\r\nimport { intArrayToBase64 } from '../lib/blob-helpers.js'\r\nimport { secondsToTime } from '../lib/strformat';\r\nimport { KEYPRESS_DELAY, MAX_DURATION, MIN_DURATION } from '../config.js';\r\n\r\n// FFT resolution.\r\nconst BUFFER_SIZE = 256;\r\n// Make canvas bigger than the element size to reduce blurring.\r\nconst CANVAS_UPSCALING = 2.0;\r\n// Thickness of a visualization bar.\r\nconst LINE_WIDTH = 3 * CANVAS_UPSCALING;\r\n// Spacing between two visualization bars.\r\nconst SPACING = 2 * CANVAS_UPSCALING;\r\n// Duration represented by one visualization bar.\r\nconst MILLIS_PER_BAR = 100;\r\n// Color of histogram bars\r\nconst BAR_COLOR = '#BBBD';\r\n// Vertical scaling for visualization bars.\r\nconst BAR_SCALE = 64.0;\r\n// Number of bars in preview.\r\nconst VISUALIZATION_BARS = 96;\r\n// Maximum number of samples per bar.\r\nconst MAX_SAMPLES_PER_BAR = 10;\r\n\r\n// Default recording format (FF, Chrome except on iOS).\r\nconst DEFAULT_AUDIO_MIME_TYPE = 'audio/webm';\r\n// Safari supports only mp4 as audio recording format.\r\nconst SAFARI_AUDIO_MIME_TYPE = 'audio/mp4';\r\nconst AUDIO_MIME_TYPES = [DEFAULT_AUDIO_MIME_TYPE, SAFARI_AUDIO_MIME_TYPE, ''];\r\n\r\nconst messages = defineMessages({\r\n  icon_title_delete: {\r\n    id: 'icon_title_delete',\r\n    defaultMessage: 'Delete recording',\r\n    description: 'Icon tool tip for deleting recorded audio'\r\n  },\r\n  icon_title_pause: {\r\n    id: 'icon_title_pause',\r\n    defaultMessage: 'Pause playback',\r\n    description: 'Icon tool tip for pausing audio playback'\r\n  },\r\n  icon_title_resume: {\r\n    id: 'icon_title_resume',\r\n    defaultMessage: 'Resume playback',\r\n    description: 'Icon tool tip for resuming audio playback'\r\n  },\r\n  icon_title_send: {\r\n    id: 'icon_title_send',\r\n    defaultMessage: 'Send message',\r\n    description: 'Icon tool tip for sending a message'\r\n  },\r\n  failed_to_init_audio: {\r\n    id: 'failed_to_init_audio',\r\n    defaultMessage: 'Failed to initialize audio recording',\r\n    description: 'Error message when audio is not available'\r\n  }\r\n});\r\n\r\nclass AudioRecorder extends React.PureComponent {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      enabled: true,\r\n      audioRecord: null,\r\n      recording: true,\r\n      paused: false,\r\n      duration: '0:00',\r\n      blobUrl: null,\r\n      preview: null\r\n    };\r\n\r\n    this.visualize = this.visualize.bind(this);\r\n    this.initMediaRecording = this.initMediaRecording.bind(this);\r\n    this.initCanvas = this.initCanvas.bind(this);\r\n    this.getRecording = this.getRecording.bind(this);\r\n    this.cleanUp = this.cleanUp.bind(this);\r\n\r\n    this.handleResume = this.handleResume.bind(this);\r\n    this.handlePause = this.handlePause.bind(this);\r\n    this.handleDelete = this.handleDelete.bind(this);\r\n    this.handleDone = this.handleDone.bind(this);\r\n\r\n    this.durationMillis = 0;\r\n    this.startedOn = null;\r\n    this.viewBuffer = [];\r\n    this.canvasRef = React.createRef();\r\n\r\n    // Timestamp for sending \"recording\" notifications.\r\n    this.recordingTimestamp = 0;\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.stream = null;\r\n    this.mediaRecorder = null;\r\n    this.audioContext = null;\r\n    this.audioInput = null;\r\n    this.analyser = null;\r\n\r\n    this.audioChunks = [];\r\n\r\n    // Start recorder right away.\r\n    try {\r\n      navigator.mediaDevices.getUserMedia({audio: true, video: false}).then(this.initMediaRecording, this.props.onError);\r\n    } catch (err) {\r\n      this.props.onError(err);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.startedOn = null;\r\n    if (this.stream) {\r\n      this.cleanUp();\r\n    }\r\n  }\r\n\r\n  // Draw amplitude of sound.\r\n  visualize() {\r\n    this.initCanvas();\r\n\r\n    const pcmData = new Uint8Array(this.analyser.frequencyBinCount);\r\n    const width = this.canvasWidth;\r\n    const height = this.canvasHeight;\r\n    // Number of bars.\r\n    const viewLength = (width / (LINE_WIDTH + SPACING)) | 0;\r\n    // Duration of audio which fits onto the screen.\r\n    const viewDuration = MILLIS_PER_BAR * viewLength;\r\n\r\n    this.canvasContext.lineWidth = LINE_WIDTH;\r\n    this.canvasContext.strokeStyle = BAR_COLOR;\r\n\r\n    let prevBarCount = 0;\r\n    let volume = 0.0;\r\n    let countPerBar = 0;\r\n    const drawFrame = _ => {\r\n      if (!this.startedOn) {\r\n        return;\r\n      }\r\n      window.requestAnimationFrame(drawFrame);\r\n\r\n      const duration = this.durationMillis + (Date.now() - this.startedOn);\r\n      // Update record length timer.\r\n      this.setState({duration: secondsToTime(duration / 1000)});\r\n\r\n      // Check if record is too long.\r\n      if (duration > MAX_DURATION) {\r\n        this.startedOn = null;\r\n        this.mediaRecorder.pause();\r\n        this.durationMillis += Date.now() - this.startedOn;\r\n        this.setState({enabled: false, recording: false, duration: secondsToTime(this.durationMillis / 1000)});\r\n      }\r\n\r\n      // Draw histogram.\r\n\r\n      // Get current waveform and calculate its amplitude.\r\n      this.analyser.getByteTimeDomainData(pcmData);\r\n      let amp = 0.0;\r\n      for (const amplitude of pcmData) {\r\n        amp += (amplitude - 127) ** 2;\r\n      }\r\n\r\n      // Sum the amplitude.\r\n      volume += Math.sqrt(amp/pcmData.length);\r\n      countPerBar ++;\r\n\r\n      let barCount = (duration / MILLIS_PER_BAR) | 0;\r\n      // Shift of the histogram along x-axis to make scrolling smooth. No need to shift if recording is too short.\r\n      const dx = viewDuration > duration ? 0 :\r\n        (duration - MILLIS_PER_BAR * barCount) / MILLIS_PER_BAR * (LINE_WIDTH + SPACING);\r\n\r\n      if (prevBarCount != barCount) {\r\n        prevBarCount = barCount;\r\n        // Add new amplitude visualization bar.\r\n        this.viewBuffer.push(volume/countPerBar);\r\n        volume = 0.0;\r\n        countPerBar = 0;\r\n        if (this.viewBuffer.length > viewLength) {\r\n          // Keep at most 'viewLength' amplitude bars.\r\n          this.viewBuffer.shift();\r\n        }\r\n      }\r\n\r\n      // Clear canvas.\r\n      this.canvasContext.clearRect(0, 0, width, height);\r\n\r\n      // Draw amplitude bars.\r\n      this.canvasContext.beginPath();\r\n      for (let i = 0; i < this.viewBuffer.length; i++) {\r\n        let x = i * (LINE_WIDTH + SPACING) - dx;\r\n        let y = Math.max(Math.min(this.viewBuffer[i] / BAR_SCALE, 0.9) * height, 1);\r\n\r\n        this.canvasContext.moveTo(x, (height - y) * 0.5);\r\n        this.canvasContext.lineTo(x, (height + y) * 0.5);\r\n      }\r\n      // Actually draw the bars on canvas.\r\n      this.canvasContext.stroke();\r\n\r\n      // Send notification, if needed.\r\n      const now = new Date().getTime();\r\n      if (now - this.recordingTimestamp > KEYPRESS_DELAY) {\r\n        this.props.onRecordingProgress();\r\n        this.recordingTimestamp = now;\r\n      }\r\n    }\r\n\r\n    drawFrame();\r\n  }\r\n\r\n  handlePause(e) {\r\n    e.preventDefault();\r\n    this.mediaRecorder.pause();\r\n    this.mediaRecorder.requestData();\r\n    this.durationMillis += Date.now() - this.startedOn;\r\n    this.startedOn = null;\r\n    this.setState({recording: false});\r\n  }\r\n\r\n  handleResume(e) {\r\n    e.preventDefault();\r\n    if (this.state.enabled) {\r\n      this.startedOn = Date.now();\r\n      this.mediaRecorder.resume();\r\n      this.setState({recording: true}, this.visualize);\r\n    }\r\n  }\r\n\r\n  handleDelete(e) {\r\n    e.preventDefault();\r\n    this.durationMillis = 0;\r\n    this.startedOn = null;\r\n    this.mediaRecorder.stop();\r\n    this.cleanUp();\r\n    this.setState({recording: false});\r\n  }\r\n\r\n  handleDone(e) {\r\n    e.preventDefault();\r\n    this.setState({recording: false});\r\n    if (this.startedOn) {\r\n      this.durationMillis += Date.now() - this.startedOn;\r\n      this.startedOn = null;\r\n    }\r\n    // Stop recording and return data.\r\n    if (this.mediaRecorder) {\r\n      this.mediaRecorder.stop();\r\n    }\r\n  }\r\n\r\n  initCanvas() {\r\n    this.canvasRef.current.width = this.canvasRef.current.offsetWidth * CANVAS_UPSCALING;\r\n    this.canvasRef.current.height = this.canvasRef.current.offsetHeight * CANVAS_UPSCALING;\r\n\r\n    this.canvasContext = this.canvasRef.current.getContext('2d');\r\n    this.canvasContext.lineCap = 'round';\r\n    // To reduce line blurring.\r\n    this.canvasContext.translate(0.5, 0.5);\r\n    this.canvasWidth = this.canvasRef.current.width;\r\n    this.canvasHeight = this.canvasRef.current.height;\r\n  }\r\n\r\n  initMediaRecording(stream) {\r\n    this.stream = stream;\r\n    AUDIO_MIME_TYPES.some(mimeType => {\r\n      if (MediaRecorder.isTypeSupported(mimeType)) {\r\n        this.mediaRecorder = new MediaRecorder(stream, {mimeType: mimeType, audioBitsPerSecond: 24_000});\r\n        return true;\r\n      }\r\n      return false;\r\n    });\r\n\r\n    if (!this.mediaRecorder) {\r\n      console.warn('MediaRecorder failed to initialize: no supported audio formats');\r\n      this.props.onError(this.props.intl.formatMessage(messages.failed_to_init_audio));\r\n      return;\r\n    }\r\n\r\n    // The following code is needed for visualization.\r\n    this.audioContext = new AudioContext();\r\n    this.audioInput = this.audioContext.createMediaStreamSource(stream);\r\n    if (!this.audioInput) {\r\n      console.warn('createMediaStreamSource returned null: audio input unavailable');\r\n      this.props.onError(this.props.intl.formatMessage(messages.failed_to_init_audio));\r\n      return;\r\n    }\r\n\r\n    this.analyser = this.audioContext.createAnalyser();\r\n    this.analyser.fftSize = BUFFER_SIZE;\r\n    this.audioInput.connect(this.analyser);\r\n\r\n    this.mediaRecorder.onstop = _ => {\r\n      if (this.durationMillis > MIN_DURATION) {\r\n        this.getRecording(this.mediaRecorder.mimeType)\r\n          .then(result => this.props.onFinished(result.url, result.preview, this.durationMillis));\r\n      } else {\r\n        this.props.onDeleted();\r\n      }\r\n      this.cleanUp();\r\n    }\r\n\r\n    this.mediaRecorder.ondataavailable = (e) => {\r\n      if (e.data.size > 0) {\r\n        this.audioChunks.push(e.data);\r\n      }\r\n\r\n      if (this.mediaRecorder.state != 'inactive') {\r\n        this.getRecording(this.mediaRecorder.mimeType).then(result => {\r\n          this.setState({\r\n            blobUrl: result.url,\r\n            preview: result.preview\r\n          });\r\n        });\r\n      }\r\n    }\r\n\r\n    this.durationMillis = 0;\r\n    this.startedOn = Date.now();\r\n    this.mediaRecorder.start();\r\n    this.visualize();\r\n\r\n    this.props.onRecordingProgress();\r\n    this.recordingTimestamp = this.startedOn;\r\n  }\r\n\r\n  // Obtain data in a form sutable for sending or playing back.\r\n  getRecording(mimeType) {\r\n    mimeType = mimeType || DEFAULT_AUDIO_MIME_TYPE;\r\n    let blob = new Blob(this.audioChunks, {type: mimeType});\r\n    // If duration is valid, apply fix for Chrome's WebM duration bug.\r\n    const result = mimeType == DEFAULT_AUDIO_MIME_TYPE ?\r\n      fixWebmDuration(blob, mimeType) :\r\n      Promise.resolve(blob);\r\n    return result\r\n      .then(fixedBlob => { blob = fixedBlob; return fixedBlob.arrayBuffer(); })\r\n      .then(arrayBuff => this.audioContext.decodeAudioData(arrayBuff))\r\n      .then(decoded => this.createPreview(decoded))\r\n      .then(preview => ({url: window.URL.createObjectURL(blob), preview: intArrayToBase64(preview)}));\r\n  }\r\n\r\n  // Preview must be calculated at the source: Chrome does not allow background AudioContext.\r\n  createPreview(audio) {\r\n    const data = audio.getChannelData(0);\r\n    // Number of amplitude bars in preview.\r\n    const viewLength = Math.min(data.length, VISUALIZATION_BARS);\r\n    // The number of samples in each bar.\r\n    const totalSPB = (data.length / viewLength) | 0;\r\n    // Distance between samples: we are going to take just a fracton of samples.\r\n    const samplingRate = Math.max(1, (totalSPB / MAX_SAMPLES_PER_BAR) | 0);\r\n\r\n    let buffer = [];\r\n    let max = -1;\r\n    for (let i = 0; i < viewLength; i++) {\r\n      let amplitude = 0;\r\n      let count = 0;\r\n      for (let j = 0; j < totalSPB; j += samplingRate) {\r\n        amplitude += data[totalSPB * i + j] ** 2;\r\n        count ++;\r\n      }\r\n      const val = Math.sqrt(amplitude / count);\r\n      buffer.push(val);\r\n      max = Math.max(max, val);\r\n    }\r\n    // Normalize amplitude to 0..100.\r\n    if (max > 0) {\r\n      buffer = buffer.map(a => (100 * a / max) | 0);\r\n    }\r\n    return buffer;\r\n  }\r\n\r\n  cleanUp() {\r\n    if (this.audioInput) {\r\n      this.audioInput.disconnect();\r\n    }\r\n    this.stream.getTracks().forEach(track => track.stop());\r\n  }\r\n\r\n  render() {\r\n    const {formatMessage} = this.props.intl;\r\n    const resumeClass = 'material-icons ' + (this.state.enabled ? 'red' : 'gray');\r\n    return (\r\n      <div className=\"audio\">\r\n        <a href=\"#\" onClick={this.handleDelete} title={formatMessage(messages.icon_title_delete)}>\r\n          <i className=\"material-icons gray\">delete_outline</i>\r\n        </a>\r\n        {this.state.recording ?\r\n          <canvas ref={this.canvasRef} />\r\n          :\r\n          <AudioPlayer\r\n            src={this.state.blobUrl}\r\n            preview={this.state.preview}\r\n            duration={this.durationMillis}\r\n            short={true} />\r\n        }\r\n        <div className=\"duration\">{this.state.duration}</div>\r\n        {this.state.recording ?\r\n          <a href=\"#\" onClick={this.handlePause} title={formatMessage(messages.icon_title_pause)}>\r\n            <i className=\"material-icons\">pause_circle_outline</i>\r\n          </a> :\r\n          <a href=\"#\" onClick={this.handleResume} title={formatMessage(messages.icon_title_resume)}>\r\n            <i className={resumeClass}>radio_button_checked</i>\r\n          </a>\r\n        }\r\n        <a href=\"#\" onClick={this.handleDone} title={formatMessage(messages.icon_title_send)}>\r\n          <i className=\"material-icons\">send</i>\r\n        </a>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default injectIntl(AudioRecorder);\r\n"],"names":["MILLIS_PER_BAR","DEFAULT_AUDIO_MIME_TYPE","AUDIO_MIME_TYPES","messages","defineMessages","icon_title_delete","id","defaultMessage","icon_title_pause","icon_title_resume","icon_title_send","failed_to_init_audio","AudioRecorder","React","constructor","props","super","this","state","enabled","audioRecord","recording","paused","duration","blobUrl","preview","visualize","bind","initMediaRecording","initCanvas","getRecording","cleanUp","handleResume","handlePause","handleDelete","handleDone","durationMillis","startedOn","viewBuffer","canvasRef","recordingTimestamp","componentDidMount","stream","mediaRecorder","audioContext","audioInput","analyser","audioChunks","navigator","mediaDevices","getUserMedia","audio","video","then","onError","err","componentWillUnmount","pcmData","Uint8Array","frequencyBinCount","width","canvasWidth","height","canvasHeight","viewLength","viewDuration","canvasContext","lineWidth","strokeStyle","prevBarCount","volume","countPerBar","drawFrame","_","window","requestAnimationFrame","Date","now","setState","secondsToTime","MAX_DURATION","pause","getByteTimeDomainData","amp","amplitude","Math","sqrt","length","barCount","dx","push","shift","clearRect","beginPath","i","x","y","max","min","moveTo","lineTo","stroke","getTime","KEYPRESS_DELAY","onRecordingProgress","e","preventDefault","requestData","resume","stop","current","offsetWidth","offsetHeight","getContext","lineCap","translate","some","mimeType","MediaRecorder","isTypeSupported","audioBitsPerSecond","AudioContext","createMediaStreamSource","createAnalyser","fftSize","connect","onstop","MIN_DURATION","result","onFinished","url","onDeleted","ondataavailable","data","size","start","console","warn","intl","formatMessage","blob","Blob","type","fixWebmDuration","Promise","resolve","fixedBlob","arrayBuffer","arrayBuff","decodeAudioData","decoded","createPreview","URL","createObjectURL","intArrayToBase64","getChannelData","totalSPB","samplingRate","buffer","count","j","val","map","a","disconnect","getTracks","forEach","track","render","resumeClass","className","href","onClick","title","ref","AudioPlayer","src","short","injectIntl"],"sourceRoot":""}